DROP PROCEDURE IF EXISTS get_word_dist_list;delimiter //CREATE PROCEDURE get_word_dist_list(	IN _word varchar(64),	IN _page INT,	IN _perpage INT,	IN _deep INT,	IN _mode varchar(10), -- [item]Item一覧/[word]Word一覧[synset]Synset一覧	IN _id varchar(32) -- 同じItemを表示させないため省くID)BEGIN	DECLARE _no INT DEFAULT 1;-- 探索用NO		-- ■ テンポラリテーブル ■	-- 距離とSynset格納用	DROP TEMPORARY TABLE IF EXISTS synlink_stack;	CREATE TEMPORARY TABLE synlink_stack (		`no` tinyint(4) NULL,		`synset0` varchar(16) NULL,		`synset1` varchar(16) NULL,		`synset2` varchar(16) NULL,		`link` varchar(10) NULL,		`dist` tinyint(4) NULL		,KEY `synset1_idx` (`synset1`)		,KEY `synset2_idx` (`synset2`)		-- ,KEY `dist_idx` (`dist`)	);		-- ↑のINSERT用	DROP TEMPORARY TABLE IF EXISTS synlink_old_stack;	CREATE TEMPORARY TABLE synlink_old_stack LIKE synlink_stack;		-- 単語と距離	DROP TEMPORARY TABLE IF EXISTS word_stack;	CREATE TEMPORARY TABLE word_stack (		`synset` varchar(16) NOT NULL,		`synset0` varchar(16) NOT NULL,		`name` varchar(64) DEFAULT NULL,		`dist` tinyint(4) NULL		,KEY `dist_idx` (`name`)	) ;	-- ■ 処理 ■	-- [synset]Synsetのlinkされてるのとその距離	SET @word = REPLACE(_word, " ", "_");	INSERT INTO synlink_stack 		SELECT DISTINCT _no, SL.synset1, SL.synset1, SL.synset2, SL.link, 			(CASE WHEN SL.link NOT IN ('attr', 'sim', 'enta') THEN 1 ELSE 0 END)			FROM wn_word AS W 			INNER JOIN wn_sense AS S USING(`wordid`) 			INNER JOIN wn_sense AS S2 USING(`synset`) 			INNER JOIN wn_synlink AS SL ON S2.synset = SL.synset1 			WHERE W.lemma = @word			GROUP BY S2.synset,SL.synset2 			ORDER BY S2.id,S2.lexid ASC 			;				-- [word]synset1から単語	INSERT INTO word_stack 		SELECT DISTINCT SY.synset, SY.synset, REPLACE(SY.name, "_", " "), 0			FROM synlink_stack AS SS			INNER JOIN wn_synset AS SY ON (SY.synset = SS.synset1)			GROUP BY SY.name 			ORDER BY dist ASC ;	     -- [synset]再帰的にSynsetのlinkをたどる	SELECT COUNT(no) INTO @cnt FROM synlink_stack WHERE no = _no; -- 現在の列数    WHILE (_no < _deep AND @cnt <> 0 AND @cnt < 500) DO		TRUNCATE TABLE synlink_old_stack; -- 空に		INSERT INTO synlink_old_stack			SELECT * FROM synlink_stack GROUP BY synset2 ORDER BY dist ASC ;-- 既に探索済みのは統合			INSERT INTO synlink_stack 			SELECT (_no + 1), SS.synset0, SL.synset1, SL.synset2, SL.link, 				(CASE WHEN SL.link NOT IN ('attr', 'sim', 'enta') THEN SS.dist+1 ELSE SS.dist END) AS dist 				FROM synlink_old_stack AS SS 				INNER JOIN wn_synlink AS SL 					ON (SL.synset1 = SS.synset2 AND SL.synset2 != SS.synset1) 				WHERE SS.no = _no -- 新しい階層NO				GROUP BY SL.synset2 				ORDER BY dist ASC ;		SET _no = _no + 1;		SELECT COUNT(no) INTO @cnt FROM synlink_stack WHERE no = _no; -- 現在の列数    END WHILE;			-- ■ 結果表示 ■	SET @start = _perpage * _page;	IF _mode = "synset" THEN 		SET @sql = CONCAT('			SELECT * FROM synlink_stack GROUP BY synset2 ORDER BY dist ASC 				LIMIT ', @start, ',', _perpage			);			ELSE -- _mode = "word" OR  _mode = "item"		-- [word]synset2から単語		INSERT INTO word_stack 			SELECT DISTINCT SY.synset, SS.synset0, REPLACE(SY.name, "_", " ") AS name, SS.dist				FROM synlink_stack AS SS				INNER JOIN wn_synset AS SY ON (SY.synset = SS.synset2)				GROUP BY name 				ORDER BY SS.dist ASC LIMIT 500;				IF _mode = "word" THEN			SET @sql = CONCAT('				SELECT * FROM word_stack 					GROUP BY name 					ORDER BY dist ASC 					LIMIT ', @start, ',', _perpage			);				ELSE			SELECT id INTO @en FROM d_language WHERE code = "en"; -- language id					-- [item] 単語からItem取得			SET @sql = CONCAT('				SELECT DISTINCT I.*, SS.synset, SS.synset0, SS.dist 					FROM word_stack AS SS 					INNER JOIN t_item_title AS IT 						ON (IT.content = SS.name AND IT.language = ', QUOTE(@en), ') 					INNER JOIN t_item AS I 						ON (IT.item = I.id AND I.disabled = 0 AND I.id != ', QUOTE(_id) , ' ) 					GROUP BY SS.name 					ORDER BY SS.dist ASC 					LIMIT ', @start, ',', _perpage			);		END IF;			END IF;		PREPARE stmt FROM @sql;	EXECUTE stmt; -- 出力実行    	END//delimiter ;